import sys
import hashlib
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import constant_time
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.serialization import load_der_private_key
from cryptography.hazmat.primitives.serialization import load_der_public_key
from cryptography.hazmat.primitives.serialization import load_pem_parameters
from cryptography.hazmat.primitives.serialization import load_der_parameters
from cryptography.hazmat.primitives.asymmetric import (dsa, rsa, padding, utils)


key_type               = rsa.RSAPublicKey
parameter_type         = dh.DHParameters
der_parameters_type    = dh.DHParameters
der_public_key_type    = rsa.RSAPublicKey
der_private_key_type   = rsa.RSAPrivateKey

def check_data_type(message_type, data_type):
    return isinstance(message_type, data_type)

# PEM is an encapsulation format, meaning keys in it can actually be any of several different key types. 
# However these are all self-identifying, so you don’t need to worry about this detail. 
# PEM keys are recognizable because they all begin with -----BEGIN {format}----- 
# and end with -----END {format}-----.

def check_pem_public_key_type(public_pem_data, key_type):
        key = load_pem_public_key(public_pem_data)
        if key:
            check_pem_key_type = check_data_type(key, key_type)
        if check_pem_key_type == True:
            return True

def check_pem_parameter_type(parameters_pem_data, parameter_type):
    parameters = load_pem_parameters(parameters_pem_data)
    if parameters:
        check_parameters_type = check_data_type(parameters, parameter_type)
    if check_parameters_type == True:
        return True

# DER is an ASN.1 encoding type. 
# There are no encapsulation boundaries and the data is binary. 
# DER keys may be in a variety of formats, 
# but as long as you know whether it is a public or private key the loading functions will handle the rest.

def check_der_private_key_type(der_data, der_private_key_type, password_type = None):
    if der_data:
        key = load_der_private_key(der_data, password=password_type)
    if key:
        check_der_private_key_type = check_data_type(key, der_private_key_type)
    if check_der_private_key_type:
        return True

def check_der_public_key_type(public_der_data, der_public_key_type):
    if public_der_data:
        key = load_der_public_key(public_der_data)
    if key:
        check_der_public_key_type = check_data_type(key, der_public_key_type)
    return True

def check_der_parameter_type(parameters_der_data):
    parameters = load_der_parameters(parameters_der_data)
    if parameters:
        check_der_paramters_type = check_data_type(parameters, der_parameters_type)
    return check_der_paramters_type


# Asymmetric Utilities

class Asymmetric_Utilities:
    def __init__(self):
        self.public_exponent = 65537
        self.key_size        = 2048
        self.message         = bytes("A message I want to sign", encoding="utf8")
        self.encoding_type   = hashlib.sha256()
        self.salt_length     = padding.PSS.MAX_LENGTH
    
    def __repr__(self):
        return self
    
    def generate_private_key(self, use_assymetric_private_key = True):
        if use_assymetric_private_key:
            private_key = rsa.generate_private_key(public_exponent=self.public_exponent,key_size=self.key_size,backend=default_backend())
        return private_key
    
    def generate_public_key(self, private_key, use_generate_public_key = True):
        if use_generate_public_key:
            public_key = private_key.public_key()
        return public_key
    
    def digest_prehased_message(self):
        prehashed_msg = self.encoding_type(self.message).digest()
        return prehashed_msg
    
    def message_signature(self, use_sign_message = True):
        if use_sign_message:
            signature = private_key.sign(prehashed_msg,padding.PSS(mgf=padding.MGF1(self.encoding_type()),salt_length=self.salt_length),utils.Prehashed(self.encoding_type))
        return signature
    
    def key_verification(self, signature, public_key, use_key_verification = True):
        if use_key_verification:
            return public_key.verify(signature,prehashed_msg,padding.PSS(mgf=padding.MGF1(self.encoding_type),salt_length=self.salt_length),utils.Prehashed(self.encoding_type))


# Constant time functions
#
# This module contains functions for operating with secret data 
# in a way that does not leak information about that data through 
# how long it takes to perform the operation. 
# These functions should be used whenever operating on secret data along with data that is user supplied.
#
# An example would be comparing a HMAC signature received from a 
# client to the one generated by the server code for authentication purposes.

# For more information about this sort of issue, 
# see Coda Hale’s blog post [ https://codahale.com/a-lesson-in-timing-attacks/ ]
# about the timing attacks on KeyCzar and Java’s MessageDigest.isEqual().
#
first_data = bytes('foo', encoding="utf8")
second_data = bytes('foo', encoding="utf8")

def check_if_equal(first_data, second_data):
    return constant_time.bytes_eq(first_data,second_data)


# Example Usage
# first_data = bytes('foo', encoding="utf8")
# second_data = bytes('foo', encoding="utf8")
# check_result = check_if_equal(first_data, second_data)
# print(check_result)
# True
#
# first_data = bytes('foo', encoding="utf8")
# second_data = bytes('fo00o', encoding="utf8")
# check_result = check_if_equal(first_data, second_data)
# print(check_result)
# False
#

# Symmetric Padding
#
# Padding is a way to take data that may or may not be a 
# multiple of the block size for a cipher and extend it out so that it is. 
# This is required for many block cipher modes as they 
# require the data to be encrypted to be an exact multiple of the block size.
#
# PKCS7 padding is a generalization of PKCS5 padding (also known as standard padding). 
# PKCS7 padding works by appending N bytes with the value of chr(N), 
# where N is the number of bytes required to make the final block of 
# data the same size as the block size. A simple example of padding is:

# Example Usage
# padded_mint = primitive_padding_with_PKCS7(padding_byte, padded_with_data)
# print(padded_mint)
# print(' ')
# print(primitive_unpadding_with_PKCS7(padding_byte, padded_mint))

padding_byte = int('128')
padded_with_data = bytes("11111111111111112222222222", encoding="utf8")

def primitive_padding_with_PKCS7(padding_byte, padded_with_data, use_symmetric_padding = True):
    try:
        from cryptography.hazmat.primitives import padding
        if use_symmetric_padding:
            padder = padding.PKCS7(padding_byte).padder()
            padded_data = padder.update(padded_with_data)
            padded_data += padder.finalize()
        return padded_data
    except Exception:
        sys.exit()

def primitive_unpadding_with_PKCS7(padding_byte, padded_data, use_symmetric_unpadding = True):
    try:
        from cryptography.hazmat.primitives import padding
        if use_symmetric_unpadding:
            unpadder = padding.PKCS7(padding_byte).unpadder()
            unpadded_data = unpadder.update(padded_data) 
        return unpadded_data + unpadder.finalize()
    except Exception:
        sys.exit()

# ANSI X9.23 padding works by appending N-1 bytes with 
# the value of 0 and a last byte with the value of chr(N), 
# where N is the number of bytes required to make the final 
# block of data the same size as the block size. 
# A simple example of padding is:
#
# Example Usage
#
# padding_mint =  primitive_padding_with_ANSIX923(padding_byte, padded_with_data)
# print(padding_mint)
# print(' ')
# print(primitive_unpadding_with_ANSIX923(padding_byte, padding_mint))

def primitive_padding_with_ANSIX923(padding_byte, padded_with_data, use_padding_with_ANSIX923 = True):
    try:
        from cryptography.hazmat.primitives import padding
        if use_padding_with_ANSIX923:
            padder = padding.ANSIX923(padding_byte).padder()
            padded_data = padder.update(padded_with_data)
            padded_data += padder.finalize()
        return padded_data
    except Exception:
        sys.exit()

def primitive_unpadding_with_ANSIX923(padding_byte, padded_data, use_unpadding_with_ANSIX923 = True):
    try:
        from cryptography.hazmat.primitives import padding
        if use_unpadding_with_ANSIX923:
            unpadder = padding.ANSIX923(padding_byte).unpadder()
            data = unpadder.update(padded_data)
        return data + unpadder.finalize()
    except Exception:
        sys.exit()
