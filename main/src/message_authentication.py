from cryptography.hazmat.primitives import cmac
from cryptography.hazmat.primitives.ciphers import algorithms

# While cryptography supports multiple MAC algorithms, 
# we strongly recommend that HMAC should be used unless you have a very specific need.
#
# For more information on why HMAC is preferred, see Use cases for CMAC vs. HMAC?



# Cipher-based message authentication codes (or CMACs) 
# are a tool for calculating message authentication codes 
# using a block cipher coupled with a secret key. 
# You can use an CMAC to verify both the integrity and authenticity of a message.
#
# A subset of CMAC with the AES-128 algorithm is described in RFC 4493.
#
# CMAC objects take a BlockCipherAlgorithm instance.

class Cipher_based_message_authentication_code:
    def __init__(self):
        self.message_to_authenticate = bytes("message to authenticate", encoding="utf8")
        self.incorrect_signature_message = bytes("an incorrect signature", encoding="utf8")
    
    def cmac_authentication(self, key, use_cmac_authenctication = True):
        if use_cmac_authenctication:
            c = cmac.CMAC(algorithms.AES(key))
            c.update(self.message_to_authenticate)
            c.finalize()
        return c
    
    # If algorithm isnâ€™t a BlockCipherAlgorithm instance then TypeError will be raised.
    # To check that a given signature is correct use the verify() method. 
    # You will receive an exception if the signature is wrong:
    
    def check_cmac_signature(self, key, use_cmac_signature = True):
        if use_cmac_signature:
            c = cmac.CMAC(algorithms.AES(key))
            c.update(self.message_to_authenticate)
            c.verify(self.incorrect_signature_message)
        return c

# Hash-based message authentication codes (or HMACs) 
# are a tool for calculating message authentication codes 
# using a cryptographic hash function coupled with a secret key. 
# You can use an HMAC to verify both the integrity and authenticity of a message.
#
# HMAC objects take a key and a HashAlgorithm instance. 
# The key should be randomly generated bytes and is 
# recommended to be equal in length to the digest_size of the hash function chosen. 
# You must keep the key secret.
#
# This is an implementation of RFC 2104.

class Hash_based_message_authentication_codes:
    def __init__(self):
        self.key = bytes('test key. Beware! A real key should use os.urandom or TRNG to generate', encoding="utf8")
