import hashlib
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import constant_time
from cryptography.hazmat.primitives.asymmetric import dh
from cryptography.hazmat.primitives.serialization import load_pem_public_key
from cryptography.hazmat.primitives.serialization import load_der_private_key
from cryptography.hazmat.primitives.serialization import load_der_public_key
from cryptography.hazmat.primitives.serialization import load_pem_parameters
from cryptography.hazmat.primitives.serialization import load_der_parameters
from cryptography.hazmat.primitives.asymmetric import (dsa, rsa, padding, utils)


key_type               = rsa.RSAPublicKey
parameter_type         = dh.DHParameters
der_parameters_type    = dh.DHParameters
der_public_key_type    = rsa.RSAPublicKey
der_private_key_type   = rsa.RSAPrivateKey

def check_data_type(message_type, data_type):
    return isinstance(message_type, data_type)

# PEM is an encapsulation format, meaning keys in it can actually be any of several different key types. 
# However these are all self-identifying, so you don’t need to worry about this detail. 
# PEM keys are recognizable because they all begin with -----BEGIN {format}----- 
# and end with -----END {format}-----.

def check_pem_public_key_type(public_pem_data, key_type):
        key = load_pem_public_key(public_pem_data)
        if key:
            check_pem_key_type = check_data_type(key, key_type)
        if check_pem_key_type == True:
            return True

def check_pem_parameter_type(parameters_pem_data, parameter_type):
    parameters = load_pem_parameters(parameters_pem_data)
    if parameters:
        check_parameters_type = check_data_type(parameters, parameter_type)
    if check_parameters_type == True:
        return True

# DER is an ASN.1 encoding type. 
# There are no encapsulation boundaries and the data is binary. 
# DER keys may be in a variety of formats, 
# but as long as you know whether it is a public or private key the loading functions will handle the rest.

def check_der_private_key_type(der_data, der_private_key_type, password_type = None):
    if der_data:
        key = load_der_private_key(der_data, password=password_type)
    if key:
        check_der_private_key_type = check_data_type(key, der_private_key_type)
    if check_der_private_key_type:
        return True

def check_der_public_key_type(public_der_data, der_public_key_type):
    if public_der_data:
        key = load_der_public_key(public_der_data)
    if key:
        check_der_public_key_type = check_data_type(key, der_public_key_type)
    return True

def check_der_parameter_type(parameters_der_data):
    parameters = load_der_parameters(parameters_der_data)
    if parameters:
        check_der_paramters_type = check_data_type(parameters, der_parameters_type)
    return check_der_paramters_type


# Asymmetric Utilities

class Asymmetric_Utilities:
    def __init__(self):
        self.public_exponent = 65537
        self.key_size        = 2048
        self.message         = bytes("A message I want to sign", encoding="utf8")
        self.encoding_type   = hashlib.sha256()
        self.salt_length     = padding.PSS.MAX_LENGTH
    
    def generate_private_key(self, use_assymetric_private_key = True):
        if use_assymetric_private_key:
            private_key = rsa.generate_private_key(public_exponent=self.public_exponent,key_size=self.key_size,)
        return private_key
    
    def generate_public_key(self, private_key, use_generate_public_key = True):
        if use_generate_public_key:
            public_key = private_key.public_key()
        return public_key
    
    def digest_prehased_message(self):
        prehashed_msg = self.encoding_type(self.message).digest()
        return prehashed_msg
    
    def message_signature(self, use_sign_message = True):
        if use_sign_message:
            signature = private_key.sign(prehashed_msg,padding.PSS(mgf=padding.MGF1(self.encoding_type()),salt_length=self.salt_length),utils.Prehashed(self.encoding_type))
        return signature
    
    def key_verification(self, signature, public_key, use_key_verification = True):
        if use_key_verification:
            return public_key.verify(signature,prehashed_msg,padding.PSS(mgf=padding.MGF1(self.encoding_type),salt_length=self.salt_length),utils.Prehashed(self.encoding_type))


# Constant time functions
#
# This module contains functions for operating with secret data 
# in a way that does not leak information about that data through 
# how long it takes to perform the operation. 
# These functions should be used whenever operating on secret data along with data that is user supplied.
#
# An example would be comparing a HMAC signature received from a 
# client to the one generated by the server code for authentication purposes.

# For more information about this sort of issue, 
# see Coda Hale’s blog post [ https://codahale.com/a-lesson-in-timing-attacks/ ]
# about the timing attacks on KeyCzar and Java’s MessageDigest.isEqual().
#
first_data = bytes('foo', encoding="utf8")
second_data = bytes('foo', encoding="utf8")

def check_if_equal(first_data, second_data):
    return constant_time.bytes_eq(first_data,second_data)


# Example Usage
# first_data = bytes('foo', encoding="utf8")
# second_data = bytes('foo', encoding="utf8")
# check_result = check_if_equal(first_data, second_data)
# print(check_result)
# True
#
# first_data = bytes('foo', encoding="utf8")
# second_data = bytes('fo00o', encoding="utf8")
# check_result = check_if_equal(first_data, second_data)
# print(check_result)
# False
#
